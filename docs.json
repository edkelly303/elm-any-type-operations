[{"name":"Order","comment":" The Order module allows you to generate a bunch of useful functions that you\ncan use to compare the custom types or record types that you define in your Elm\napplications.\n\nThese functions will work even though custom types and record types are not\nincluded in Elm's built-in `comparable` typeclass.\n\n\n# Interface\n\nAn `Interface` is just a record containing functions that can be used to\ncompare your custom types.\n\nThe type signature might look daunting, but in practice you can ignore it.\nAll you need to remember is that if you create an `Interface` called `order`,\nyou can call the functions within it by doing `order.compare`, `order.greater`,\nand so on:\n\n    type Example\n        = A\n        | B\n        | C\n\n    toInt : Example -> Int\n    toInt example =\n        case example of\n            A ->\n                0\n\n            B ->\n                1\n\n            C ->\n                2\n\n    order =\n        Order.makeInterface toInt\n\n    thisIsTrue =\n        order.greater A B == B\n\n@docs Interface\n\n@docs makeInterface\n\n\n# Operators\n\n@docs Op\n\n@docs eq\n\n@docs neq\n\n@docs gt\n\n@docs gte\n\n@docs lt\n\n@docs lte\n\n","unions":[{"name":"Op","comment":" The type of the operator used with the `op` function\n","args":[],"cases":[]}],"aliases":[{"name":"Interface","comment":" The `Interface` type is a record of functions that you can use to compare\nthe values of your custom types, even though Elm's custom types are not\n`comparable`.\n\n\n## `op`\n\nProvides an equivalent to Elm's comparison operators `(==)`, `(/=)`, `(>)`,\n`(<)`, `(>=)` and `(<=)`, so you can compare two values of your custom type and\nget a `Bool` in response.\n\n    order.op A eq A == True\n\n    order.op A neq A == False\n\n    order.op A gt B == False\n\n    order.op A lt B == True\n\n    order.op B gte C == False\n\n    order.op A lte A == True\n\n\n## `compare`\n\nThe equivalent of `Basics.compare`\n\n    order.compare A B == Basics.LT\n\n    order.compare B A == Basics.GT\n\n    order.compare A A == Basics.EQ\n\n\n## `greater`\n\nThe equivalent of `Basics.max`\n\n    order.greater A B == B\n\n    order.greater C A == C\n\n\n## `lesser`\n\nThe equivalent of `Basics.min`\n\n    order.lesser A B == A\n\n    order.lesser C A == A\n\n(I always get confused with `min` and `max`; I think `greater` and `lesser` are\nclearer names.)\n\n\n## `greatest`\n\nThe equivalent of `List.maximum`\n\n    order.greatest [] == Nothing\n\n    order.greatest [ A, B, C ] == Just C\n\n\n## `least`\n\nThe equivalent of `List.minimum`\n\n    order.least [] == Nothing\n\n    order.least [ A, B, C ] == Just A\n\n(Similarly, I think `greatest` and `least` are clearer than `maximum` and\n`minimum`.)\n\n","args":["a"],"type":"{ op : a -> Order.Op -> a -> Basics.Bool, compare : a -> a -> Basics.Order, greater : a -> a -> a, lesser : a -> a -> a, greatest : List.List a -> Maybe.Maybe a, least : List.List a -> Maybe.Maybe a }"}],"values":[{"name":"eq","comment":" The equal operator, equivalent to `(==)`, to be used with the `op` function\n","type":"Order.Op"},{"name":"gt","comment":" The greater-than operator, equivalent to `(>)`, to be used with the `op` function\n","type":"Order.Op"},{"name":"gte","comment":" The greater-than-or-equal-to operator, equivalent to `(>=)`, to be used with the `op` function\n","type":"Order.Op"},{"name":"lt","comment":" The less-than operator, equivalent to `(<)`, to be used with the `op` function\n","type":"Order.Op"},{"name":"lte","comment":" The less-than-or-equal-to operator, equivalent to `(<=)`, to be used with the `op` function\n","type":"Order.Op"},{"name":"makeInterface","comment":" To define an `Interface`, you just need to supply a function that converts\nyour custom type to a `comparable` (i.e. a `String`, `Int` or `Float`, or a\n`Tuple` that contains only comparable values).\n\nHere's an example for \"enum\" types\n\n    type Colour\n        = Red\n        | Green\n        | Blue\n\n    colourToString : Example -> String\n\n    toString example =\n        case example of\n            Green ->\n                \"green\"\n\n            Blue ->\n                \"blue\"\n\n            Red ->\n                \"red\"\n\n    colourOrder =\n        Order.makeInterface colourToString\n\n    thisIsTrue =\n        colourOrder.op Red neq Blue == True\n\nAnd here's an example for \"wrapper\" types\n\n    type Wrapper\n        = Wrapper Int\n\n    wrapperToInt : Wrapper -> Int\n    wrapperToInt (Wrapper int) =\n        int\n\n    wrapperOrder =\n        Order.makeInterface wrapperToInt\n\n    thisIsTrueToo =\n        wrapperOrder.greatest [ Wrapper 1, Wrapper 2, Wrapper 3 ] == Just (Wrapper 3)\n\n","type":"(a -> comparable) -> Order.Interface a"},{"name":"neq","comment":" The not-equal operator, equivalent to `(/=)`, to be used with the `op` function\n","type":"Order.Op"}],"binops":[]}]