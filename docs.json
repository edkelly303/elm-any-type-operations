[{"name":"Arithmetic","comment":" The `Arithmetic` module allows you to generate a function (`Interface`) that you\ncan use to perform arithmetic operations easily on your custom and record types.\n\n\n## What is an Interface?\n\nAn `Interface` is just a function that you can define at the top level of your\nmodules to specify how to apply arithmetic operations to your types.\n\nIf you create an `Interface` called `arith`, you can then perform calculations\nas follows:\n\n    import Arithmetic exposing (add, makeIntegerInterface)\n\n    type Length\n        = Length Int\n\n    arith =\n        makeIntegerInterface\n            { toInt = \\(Length int) -> int\n            , fromInt = Length\n            }\n\n    thisIsTrue =\n        arith (Length 1) add (Length 2) == Length 3\n\n\n## Interface type\n\n@docs Interface\n\n\n## Creating an Interface\n\n@docs makeIntegerInterface\n\n@docs makeFloatInterface\n\n@docs makeInterface\n\n\n## Operators\n\n@docs Op\n\n@docs add\n\n@docs sub\n\n@docs mul\n\n@docs div\n\n@docs div0\n\n@docs divM\n\n","unions":[{"name":"Op","comment":" A type comprising the arithmetic operators that you can use with the\nInterface function\n","args":[],"cases":[]}],"aliases":[{"name":"Interface","comment":" An interface is just a function that you can use to perform arithmetic with\nwhatever types you've defined. Use one of the `makeInterface` functions to\ndefine an interface at the top level of the same module where you've defined\nyour type.\n","args":["a"],"type":"a -> Arithmetic.Op -> a -> a"}],"values":[{"name":"add","comment":" Equivalent to `(+)`, or whatever the equivalent addition operation should be\nfor your type.\n\n    arith (Length 6) add (Length 2) == Length 8\n\n","type":"Arithmetic.Op"},{"name":"div","comment":" Equivalent to `(//)` or `(/)`, or whatever the equivalent division operation\nshould be for your type.\n\n    arith (Length 6) div (Length 2) == Length 3\n\n","type":"Arithmetic.Op"},{"name":"div0","comment":" Equivalent to `(//)` or `(/)`, or whatever the equivalent division operation\nshould be for your type, except that division by zero returns zero.\n\n    arith (Length 6) div0 (Length 2) == Length 3\n\n    arith (Length 6) div0 (Length 0) == Length 0\n\n","type":"Arithmetic.Op"},{"name":"divM","comment":" Equivalent to `(//)` or `(/)`, or whatever the equivalent division operation\nshould be for your type, except that division by zero returns the lowest\nnegative number.\n\n    arith (Length 6) divM (Length 2) == Length 3\n\n    arith (Length 6) divM (Length 0) == Length -2147483648\n\n","type":"Arithmetic.Op"},{"name":"makeFloatInterface","comment":" Create an interface that can perform float arithmetic on your custom type.\n\n    type Width\n        = Width Float\n\n    arith =\n        makeFloatInterface\n            { toFloat = \\(Width flt) -> flt\n            , fromFloat = Width\n            }\n\nThis gives you the following possibilities:\n\n    arith (Width 6.0) add (Width 2.0) == Width 8.0\n\n    arith (Width 6.0) sub (Width 2.0) == Width 4.0\n\n    arith (Width 6.0) mul (Width 2.0) == Width 12.0\n\n    arith (Width 6.0) div (Width 2.0) == Width 3.0\n\nThere are also two other variants of `div`, called `div0` and `divM`.\nThese behave the same as `div`, except in their handling of division by zero.\n\n    -- `div`: dividing a non-zero number by zero returns Infinity\n    arith (Width 1.0) div (Width 0.0) == Width Infinity\n\n    -- `div`: dividing zero by zero returns NaN\n    arith (Width 0.0) div (Width 0.0) == Width NaN\n\n    -- `div0`: division by zero returns zero\n    arith (Width 6.0) div0 (Width 0.0) == Width 0.0\n\n    -- `divM`: division by zero returns Elm's minimum float\n    arith (Width 6.0) divM (Width 0.0) == Width -1.79e308\n\n","type":"{ toFloat : a -> Basics.Float, fromFloat : Basics.Float -> a } -> Arithmetic.Interface a"},{"name":"makeIntegerInterface","comment":" Create an interface that can perform integer arithmetic on your custom type.\n\n    arith =\n        makeIntegerInterface\n            { toInt = \\(Length int) -> int\n            , fromInt = Length\n            }\n\nThis gives you the following possibilities:\n\n    arith (Length 6) add (Length 2) == Length 8\n\n    arith (Length 6) sub (Length 2) == Length 4\n\n    arith (Length 6) mul (Length 2) == Length 12\n\n    arith (Length 6) div (Length 2) == Length 3\n\nThere are also two other variants of `div`, called `div0` and `divM`.\nThese behave the same as `div`, except in their handling of division by zero.\n\n    -- `div`: division by zero causes a runtime exception\n    arith (Length 6) div (Length 0) == Debug.todo \"CRASH!\"\n\n    -- `div0`: division by zero returns zero\n    arith (Length 6) div0 (Length 0) == Length 0\n\n    -- `divM`: division by zero returns Elm's minimum integer\n    arith (Length 6) divM (Length 0) == Length -2147483648\n\n","type":"{ toInt : a -> Basics.Int, fromInt : Basics.Int -> a } -> Arithmetic.Interface a"},{"name":"makeInterface","comment":" A more generic way to create an Interface, which you might need to use if\nyou want to define your own custom arithmetic rules.\n\nAs a silly example, here's a way to reimplement Elm's integer arithmetic and\nsupplement it with `div0` and `divM`:\n\n    arith =\n        makeInterface\n            { add = (+)\n            , sub = (-)\n            , mul = (*)\n            , div = (//)\n            , div0 =\n                \\a1 a2 ->\n                    if a2 == 0 then\n                        0\n\n                    else\n                        a1 // a2\n            , divM =\n                \\a1 a2 ->\n                    if a2 == 0 then\n                        -2147483648\n\n                    else\n                        a1 // a2\n            }\n\n    thisIsTrue =\n        arith 10 div0 2 == 5\n\n","type":"{ add : a -> a -> a, sub : a -> a -> a, mul : a -> a -> a, div : a -> a -> a, div0 : a -> a -> a, divM : a -> a -> a } -> Arithmetic.Interface a"},{"name":"mul","comment":" Equivalent to `(*)`, or whatever the equivalent multiplication operation\nshould be for your type.\n\n    arith (Length 6) mul (Length 2) == Length 12\n\n","type":"Arithmetic.Op"},{"name":"sub","comment":" Equivalent to `(-)`, or whatever the equivalent subtraction operation should\nbe for your type.\n\n    arith (Length 6) sub (Length 2) == Length 4\n\n","type":"Arithmetic.Op"}],"binops":[]},{"name":"Enum","comment":" The `Enum` module allows you to generate a bunch of useful functions (an\n`Interface`) that you can use to work with custom types that have a finite number\nof variants, aka enums.\n\nFor example, this is an enum:\n\n    type Season\n        = Spring\n        | Summer\n        | Autumn\n        | Winter\n\nBecause it only has a finite number of possible values (4).\n\nThis _isn't_ an enum:\n\n    type Id\n        = Id Int\n\nBecause there is an infinite series of integers, so you can't fully enumerate\nall the values of this type.\n\nThe `Enum` module gives you all the same functions as the `Order` module, plus a few\nextra ones that may come in handy when working with enums.\n\n\n## What is an Interface?\n\nAn `Interface` is just a record containing functions that you can apply to your\nenum types.\n\nThe type signature might look daunting, but in practice you can ignore it.\nAll you need to remember is that if you create an `Interface` called `enum`,\nyou can call the functions within it by doing `enum.all`, `enum.first`,\n`enum.next`, and so on:\n\n    type Example\n        = A\n        | B\n        | C\n\n    enum =\n        Enum.makeInterface A B [ C ]\n\n    thisIsTrue =\n        enum.next A == Just B\n\n\n## Interface type\n\n@docs Interface\n\n\n## Creating an Interface\n\n@docs makeInterface\n\n\n## Operators\n\n@docs Op\n\n@docs eq\n\n@docs neq\n\n@docs gt\n\n@docs gte\n\n@docs lt\n\n@docs lte\n\n","unions":[],"aliases":[{"name":"Interface","comment":" The `Interface` type is a record containing functions that you can use to\ncompare the values of your custom types, even though Elm's custom types are not\n`comparable`.\n\nThe available functions are:\n\n\n## `op`\n\nProvides an equivalent to Elm's comparison operators `(==)`, `(/=)`, `(>)`,\n`(<)`, `(>=)` and `(<=)`, so you can compare two values of your custom type and\nget a `Bool` in response.\n\n    enum.op A eq A == True\n\n    enum.op A neq A == False\n\n    enum.op A gt B == False\n\n    enum.op A lt B == True\n\n    enum.op B gte C == False\n\n    enum.op A lte A == True\n\n\n## `compare`\n\nThe equivalent of `Basics.compare`\n\n    enum.compare A B == Basics.LT\n\n    enum.compare B A == Basics.GT\n\n    enum.compare A A == Basics.EQ\n\n\n## `greater`\n\nThe equivalent of `Basics.max`\n\n    enum.greater A B == B\n\n    enum.greater C A == C\n\n\n## `lesser`\n\nThe equivalent of `Basics.min`\n\n    enum.lesser A B == A\n\n    enum.lesser C A == A\n\n(I always get confused with `min` and `max`; I think `greater` and `lesser` are\nclearer names.)\n\n\n## `greatest`\n\nThe equivalent of `List.maximum`\n\n    enum.greatest [] == Nothing\n\n    enum.greatest [ A, B, C ] == Just C\n\n\n## `least`\n\nThe equivalent of `List.minimum`\n\n    enum.least [] == Nothing\n\n    enum.least [ A, B, C ] == Just A\n\n(Similarly, I think `greatest` and `least` are clearer than `maximum` and\n`minimum`.)\n\n\n## `all`\n\nReturns a list of all the values of the enum, in order from least to greatest\n\n    enum.all == [ A, B, C ]\n\n\n## `first`\n\nReturns the first (least) value of the enum\n\n    enum.first == A\n\n\n## `last`\n\nReturns the last (greatest) value of the enum\n\n    enum.last == C\n\n\n## `next`\n\nGiven a value of the enum, returns the next (greater) value, or Nothing if no greater value exists\n\n    enum.next B == Just C\n\n    enum.next C == Nothing\n\n\n## `previous`\n\nGiven a value of the enum, returns the previous (lesser) value, or Nothing if no lesser value exists\n\n    enum.previous B == Just A\n\n    enum.previous A == Nothing\n\n","args":["enum"],"type":"{ op : enum -> Order.Op -> enum -> Basics.Bool, compare : enum -> enum -> Basics.Order, greater : enum -> enum -> enum, lesser : enum -> enum -> enum, greatest : List.List enum -> Maybe.Maybe enum, least : List.List enum -> Maybe.Maybe enum, all : List.List enum, first : enum, last : enum, next : enum -> Maybe.Maybe enum, previous : enum -> Maybe.Maybe enum }"},{"name":"Op","comment":" A type comprising the comparison operators that you can use with the `op`\nfunction. (This is re-exported from the `Order` module for convenience.)\n","args":[],"type":"Order.Op"}],"values":[{"name":"eq","comment":" The equal-to operator, equivalent to `(==)`. (This is re-exported from the\n`Order` module for convenience.)\n","type":"Order.Op"},{"name":"gt","comment":" The greater-than operator, equivalent to `(>)`. (This is re-exported from\nthe `Order` module for convenience.)\n","type":"Order.Op"},{"name":"gte","comment":" The greater-than-or-equal-to operator, equivalent to `(>=)`. (This is\nre-exported from the `Order` module for convenience.)\n","type":"Order.Op"},{"name":"lt","comment":" The less-than operator, equivalent to `(<)`. (This is re-exported from the\n`Order` module for convenience.)\n","type":"Order.Op"},{"name":"lte","comment":" The less-than-or-equal-to operator, equivalent to `(<=)`. (This is\nre-exported from the `Order` module for convenience.)\n","type":"Order.Op"},{"name":"makeInterface","comment":" To define an `Interface`, you just need to supply all the values of the\nenum, in order from least to greatest.\n\nIt only makes sense to treat a custom type as an enum if it has two or more\nvariants, so the API for `makeInterface` requires you to supply at least two\nvalues as the first two arguments. If there are more than two values, you can\nput the rest in a list as the third argument.\n\n    type Season\n        = Spring\n        | Summer\n        | Autumn\n        | Winter\n\n    enum =\n        Enum.makeInterface Spring Summer [ Autumn, Winter ]\n\n    thisIsTrue =\n        enum.next Summer == Autumn\n\n    thisIsTrueToo =\n        enum.op Winter gt Autumn == True\n\n","type":"enum -> enum -> List.List enum -> Enum.Interface enum"},{"name":"neq","comment":" The not-equal-to operator, equivalent to `(/=)`. (This is re-exported from the\n`Order` module for convenience.)\n","type":"Order.Op"}],"binops":[]},{"name":"Order","comment":" The `Order` module allows you to generate a bunch of useful functions (an\n`Interface`) that you can use to compare the custom types or record types that you\ndefine in your Elm applications.\n\nThese functions will work even though custom types and record types are not\nincluded in Elm's built-in `comparable` typeclass.\n\n\n## What is an Interface?\n\nAn `Interface` is just a record containing functions that can be used to\ncompare your custom types.\n\nThe type signature might look daunting, but in practice you can ignore it.\nAll you need to remember is that if you create an `Interface` called `order`,\nyou can call the functions within it by doing `order.compare`, `order.greater`,\nand so on:\n\n    type Example\n        = A\n        | B\n        | C\n\n    toInt : Example -> Int\n    toInt example =\n        case example of\n            A ->\n                0\n\n            B ->\n                1\n\n            C ->\n                2\n\n    order =\n        Order.makeInterface toInt\n\n    thisIsTrue =\n        order.greater A B == B\n\n\n## Interface type\n\n@docs Interface\n\n\n## Creating an interface\n\n@docs makeInterface\n\n\n## Operators\n\n@docs Op\n\n@docs eq\n\n@docs neq\n\n@docs gt\n\n@docs gte\n\n@docs lt\n\n@docs lte\n\n","unions":[{"name":"Op","comment":" A type comprising the comparison operators that you can use with the `op`\nfunction\n","args":[],"cases":[]}],"aliases":[{"name":"Interface","comment":" The `Interface` type is a record containing functions that you can use to\ncompare the values of your custom types, even though Elm's custom types are not\n`comparable`.\n\nThe available functions are:\n\n\n## `op`\n\nProvides an equivalent to Elm's comparison operators `(==)`, `(/=)`, `(>)`,\n`(<)`, `(>=)` and `(<=)`, so you can compare two values of your custom type and\nget a `Bool` in response.\n\n    order.op A eq A == True\n\n    order.op A neq A == False\n\n    order.op A gt B == False\n\n    order.op A lt B == True\n\n    order.op B gte C == False\n\n    order.op A lte A == True\n\n\n## `compare`\n\nThe equivalent of `Basics.compare`\n\n    order.compare A B == Basics.LT\n\n    order.compare B A == Basics.GT\n\n    order.compare A A == Basics.EQ\n\n\n## `greater`\n\nThe equivalent of `Basics.max`\n\n    order.greater A B == B\n\n    order.greater C A == C\n\n\n## `lesser`\n\nThe equivalent of `Basics.min`\n\n    order.lesser A B == A\n\n    order.lesser C A == A\n\n(I always get confused with `min` and `max`; I think `greater` and `lesser` are\nclearer names.)\n\n\n## `greatest`\n\nThe equivalent of `List.maximum`\n\n    order.greatest [] == Nothing\n\n    order.greatest [ A, B, C ] == Just C\n\n\n## `least`\n\nThe equivalent of `List.minimum`\n\n    order.least [] == Nothing\n\n    order.least [ A, B, C ] == Just A\n\n(Similarly, I think `greatest` and `least` are clearer than `maximum` and\n`minimum`.)\n\n","args":["a"],"type":"{ op : a -> Order.Op -> a -> Basics.Bool, compare : a -> a -> Basics.Order, greater : a -> a -> a, lesser : a -> a -> a, greatest : List.List a -> Maybe.Maybe a, least : List.List a -> Maybe.Maybe a }"}],"values":[{"name":"eq","comment":" The equal-to operator, equivalent to `(==)`\n","type":"Order.Op"},{"name":"gt","comment":" The greater-than operator, equivalent to `(>)`\n","type":"Order.Op"},{"name":"gte","comment":" The greater-than-or-equal-to operator, equivalent to `(>=)`\n","type":"Order.Op"},{"name":"lt","comment":" The less-than operator, equivalent to `(<)`\n","type":"Order.Op"},{"name":"lte","comment":" The less-than-or-equal-to operator, equivalent to `(<=)`\n","type":"Order.Op"},{"name":"makeInterface","comment":" To define an `Interface`, you just need to supply a function that converts\nyour custom type to a `comparable` (i.e. a `String`, `Int` or `Float`, or a\n`Tuple` that contains only comparable values).\n\nHere's an example for \"enum\" types\n\n    type Animal\n        = Aardvark\n        | Bear\n        | Capybara\n\n    animalToString : Animal -> String\n    animalToString example =\n        case example of\n            Aardvark ->\n                \"aardvark\"\n\n            Bear ->\n                \"bear\"\n\n            Capybara ->\n                \"capybara\"\n\n    order : Interface Animal\n    order =\n        Order.makeInterface animalToString\n\n    thisIsTrue =\n        order.op Aardvark lte Bear == True\n\nAnd here's an example for \"wrapper\" types\n\n    type Wrapper\n        = Wrapper Int\n\n    wrapperToInt : Wrapper -> Int\n    wrapperToInt (Wrapper int) =\n        int\n\n    order : Order Wrapper\n    order =\n        Order.makeInterface wrapperToInt\n\n    thisIsTrueToo =\n        order.greatest\n            [ Wrapper 1\n            , Wrapper 2\n            , Wrapper 3\n            ]\n            == Just (Wrapper 3)\n\n","type":"(a -> comparable) -> Order.Interface a"},{"name":"neq","comment":" The not-equal-to operator, equivalent to `(/=)`\n","type":"Order.Op"}],"binops":[]}]